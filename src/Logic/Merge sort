    Linked list merge sort

    public LinkedList merge(LinkedList A, LinkedList B)
    {
        //Create a new linked list, fa,fb included for scope.
        LinkedList sortedList = new LinkedList();
        Comparable fa,fb;
        // While A is not empty and B is not empty
        while(!A.isEmpty() && !B.isEmpty())
        {
            fa = (Comparable)A.getFirst();//return first piece of data elements but not delete
            fb = (Comparable)B.getFirst();
            //if fa < fb
            if(fa.compareTo(fb) < 0)
            {
                A.removeFirst();//a becomes shorter
                sortedList.addLast(fa);//O1
            }
            else
            {
                B.removeFirst();// B becomes shorter
                sortedList.addLast(fb);// O1
            }
        }
        while(!A.isEmpty())
        {
            fa = (Comparable)A.getFirst();
            sortedList.addLast(fa);// O1
            A.removeFirst();
        }
        while(!B.isEmpty())
        {
            fb = (Comparable)B.getFirst();
            sortedList.addLast(fb); // O1
            B.removeFirst();
        }
        // return S
        return sortedList;
    }
    /**
     * Need:
     * Merge sort goes into this class
     * in
     */
    public void mergeSort() throws Exception
    {
        // Create queue object q, then enqueue each data object in the
        // linked list to be sorted, as a single-node linked list.
        Queue q = new Queue();
        //for each data object in the linked list to be sorted
        for(Node cur = this.head.next; cur != this.head ;cur = cur.next)
        {
            //create a new linked list object, newList = new LinkedList
            LinkedList list = new LinkedList();
            list.addLast(cur.data);
            q.enqueue(list);
        }
        //while there is more than one item in the Queue q
        while(q.size() > 1)
        {
            //dequeue and assign to LinkedList reference sublist1
            LinkedList sublist1 = (LinkedList)q.dequeue();
            //dequeue again and assign to another LLR sublist2
            LinkedList sublist2 = (LinkedList)q.dequeue();
            //walk through sorted sub1 and sub2 and merge them into a larger sorted list tempList
            LinkedList tempList = merge(sublist1, sublist2);
            q.enqueue(tempList);
        }
        //dequeue your sorted linked list.
        LinkedList sortedList = (LinkedList)q.dequeue();
        //connect the head of the original LL to the head of sorted LL
        this.head = sortedList.head;
    }

    Need: merge sort on an array

    Merge sort on array
    Assume you have a 4 element array
    A = [10, -2, 5, 0]
         low        high
    index 0,  1, 2, 3
    mid = (low + high) / 2
    left subarray from low to mid
    right subarray from mid to high
    merge sort on left subarray
    merge sort on right subarray
    A = [2,10 | 0,5]
 sorted left   s.right
 merge the two sorted arrays
    A = [0,2,5,10]
    mergeSort(A, 0, 3) //array, low, high

    	public void mergeSort( Comparable array[] ) {
    		mergeSort( array, 0, array.length - 1 );
    	}

    	private void mergeSort( Comparable [] array, int low, int high )
    	{
    		if(low < high) {
    			int mid = (low + high) / 2;
    			mergeSort(array, low, mid);
    			mergeSort(array, mid + 1, high);
    			merge(array, low, mid, high);
    		}
    	}

    	private void merge( Comparable [] array, int low, int mid, int high)
    	{
    		int leftIndex = low, rightIndex = mid + 1;
    		int tempIndex = low;
    		Object temp[] = new Object[array.length];

    		while( leftIndex  <= mid && rightIndex <= high )
    		{
    			if( array[leftIndex].compareTo(array[rightIndex]) <= 0 )
    			{
    				temp[tempIndex] = array[leftIndex];
    				leftIndex ++;
    			}
    			else
    			{
    				temp[tempIndex] = array[rightIndex];
    				rightIndex ++;
    			}
    			tempIndex ++;
    		}//end of while
    		while( leftIndex  <= mid )
    		{
    			temp[tempIndex] = array[leftIndex];
    			leftIndex ++;
    			tempIndex ++;
    		}

    		while(rightIndex <=high)
    		{
    			temp[tempIndex] = array[rightIndex];
    			rightIndex ++;
    			tempIndex ++;
    		}

    		for( tempIndex = low; tempIndex <= high; tempIndex ++)
    			array[tempIndex] = (Comparable)temp[tempIndex];
    	}//end of merge method
